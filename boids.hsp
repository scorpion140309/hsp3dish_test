; boids.hsp
#include "hsp3dish.as"
#include "BoidAppParam.as"
#include "BoidObject.as"
#include "BoidPlayer.as"
#include "DrawSomething.as"
#include "UserInput.as"

#const NUM_BOIDS 24
#const SCRW 640.0
#const SCRH 800.0

;----------------------------------------
; 初期化
;----------------------------------------
screen 0, int(SCRW), int(SCRH)
cls
randomize

; player
newmod player, BoidPlayer
setX@BoidPlayer player, double(SCRW/2)
setY@BoidPlayer player, double(SCRH/2)

; parameters
newmod param, BoidParam

; Boid 配列生成
repeat NUM_BOIDS
	newmod boids, BoidObject
loop

; Boid 初期化（ランダム）
repeat NUM_BOIDS
	setX@BoidObject boids(cnt), double(rnd(SCRW))
	setY@BoidObject boids(cnt), double(rnd(SCRH))
	;a = double(rnd(628)) / 100.0
	range = int(getMaxSpeed@BoidParam(param))
	a = double(rnd(range))
	setVX@BoidObject boids(cnt), cos(a)
	setVY@BoidObject boids(cnt), sin(a)
loop

; 実行制御
running = 1

; マウス座標（初期は画面中央）
mx = double(SCRW/2)
my = double(SCRH/2)

;----------------------------------------
; メインループ
;----------------------------------------
*main
	;
	Update@BoidPlayer player, mousex, mousey

	; マウスがウィンドウ内ならプレイヤー影響を有効、外なら無効
	if mx >= 0 & mx < SCRW & my >= 0 & my < SCRH {
		setFlagEnabled@BoidPlayer player, 1
	} else {
		setFlagEnabled@BoidPlayer player, 0
	}

	;
	Key@UserInput param, player, running

	redraw 0
	gmode 0
	color 0,0,0 : boxf

	if running = 1 {
		gosub *updateBoids
	}

	//gosub *drawParams
	gosub *DrawBoidSingles
	Player@Draw player, 8
	Information@Draw param, player, running

	redraw 1
	await 16
	goto *main


;----------------------------------------
; Boid 更新（群行動 + プレイヤー追従/回避）
;----------------------------------------
*updateBoids
	vision = getVision@BoidParam(param)
	sepR   = getSeparateR@BoidParam(param)
	cohK   = getCohesionK@BoidParam(param)
	aliK   = getAlignmentK@BoidParam(param)
	sepK   = getSeparationK@BoidParam(param)
	maxSpd = getMaxSpeed@BoidParam(param)
	wmode  = getWallMode@BoidParam(param)

	mouseK = 0.12

	; プレイヤー情報をローカルに取り出す
	pradius = getRadius@BoidPlayer(player)
	pmode = getMode@BoidPlayer(player)
	px = getX@BoidPlayer(player)
	py = getY@BoidPlayer(player)
	pflag = getFlagEnabled@BoidPlayer(player)

	repeat NUM_BOIDS
		i = cnt
		x = getX@BoidObject(boids(i))
		y = getY@BoidObject(boids(i))
		vx = getVX@BoidObject(boids(i))
		vy = getVY@BoidObject(boids(i))

		sumx = 0.0 : sumy = 0.0
		sumvx = 0.0 : sumvy = 0.0
		sepx = 0.0 : sepy = 0.0
		nCoh = 0 : nSep = 0

		repeat NUM_BOIDS
			j = cnt
			if j = i { continue }
			x2 = getX@BoidObject(boids(j))
			y2 = getY@BoidObject(boids(j))
			vx2 = getVX@BoidObject(boids(j))
			vy2 = getVY@BoidObject(boids(j))

			dx = x2 - x
			dy = y2 - y
			d2 = dx*dx + dy*dy
			if d2 = 0.0 { continue }

			if d2 < vision * vision {
				sumx += x2 : sumy += y2
				sumvx += vx2 : sumvy += vy2
				nCoh++
			}

			if d2 < sepR * sepR {
				d = sqrt(d2)
				if d > 0.0 {
					sepx += (x - x2) / d
					sepy += (y - y2) / d
					nSep++
				}
			}
		loop

		; Cohesion + Alignment
		if nCoh > 0 {
			avgx = sumx / nCoh : avgy = sumy / nCoh
			vx += (avgx - x) * cohK
			vy += (avgy - y) * cohK

			avgvx = sumvx / nCoh : avgvy = sumvy / nCoh
			vx += (avgvx - vx) * aliK
			vy += (avgvy - vy) * aliK
		}

		; Separation
		if nSep > 0 {
			vx += sepx * sepK
			vy += sepy * sepK
		}

		; プレイヤー誘導/回避（有効フラグかつ半径内のみ）
		if pflag != 0 {
			ddx = px - x
			ddy = py - y
			dd = sqrt(ddx*ddx + ddy*ddy)
			if dd > 0.0 & dd < pradius {
				if pmode = 1 {
					vx += (ddx / dd) * mouseK
					vy += (ddy / dd) * mouseK
				} else {
					if pmode = 2 {
						vx -= (ddx / dd) * mouseK
						vy -= (ddy / dd) * mouseK
					}
				}
			}
		}

		; 速度制限
		sp = sqrt(vx*vx + vy*vy)
		if sp > maxSpd {
			vx = vx / sp * maxSpd
			vy = vy / sp * maxSpd
		}

		; 位置更新
		x += vx : y += vy

		; 壁処理（Wrap / Reflect）
		if wmode = 0 {
			if x < 0.0 { x += SCRW }
			if x >= SCRW { x -= SCRW }
			if y < 0.0 { y += SCRH }
			if y >= SCRH { y -= SCRH }
		} else {
			if x < 0.0 { x = 0.0 : vx = -vx }
			if x > SCRW { x = SCRW : vx = -vx }
			if y < 0.0 { y = 0.0 : vy = -vy }
			if y > SCRH { y = SCRH : vy = -vy }
		}

		setX@BoidObject boids(i), x
		setY@BoidObject boids(i), y
		setVX@BoidObject boids(i), vx
		setVY@BoidObject boids(i), vy
	loop
	return

;----------------------------------------
; Boid 描画（三角形）
;----------------------------------------
*DrawBoidSingles
	repeat NUM_BOIDS
		BoidSingle@Draw boids(cnt), 8.0
	loop
	return

