; boids.hsp
#include "hsp3dish.as"
#include "BoidParam.as"
#include "BoidObject.as"
#include "BoidPlayer.as"

#const NUM_BOIDS 24
#const SCRW 640.0
#const SCRH 800.0
pi = 3.14159265358979

;----------------------------------------
; 初期化
;----------------------------------------
screen 0, int(SCRW), int(SCRH)
cls
randomize

; player
newmod player, BoidPlayer
setX@BoidPlayer player, double(SCRW/2)
setY@BoidPlayer player, double(SCRH/2)

; parameters
newmod param, BoidParam

; Boid 配列生成
repeat NUM_BOIDS
	newmod boids, BoidObject
loop

; Boid 初期化（ランダム）
repeat NUM_BOIDS
	setX@BoidObject boids(cnt), double(rnd(SCRW))
	setY@BoidObject boids(cnt), double(rnd(SCRH))
	a = double(rnd(628)) / 100.0
	setVX@BoidObject boids(cnt), cos(a)
	setVY@BoidObject boids(cnt), sin(a)
loop

; 実行制御
running = 1

; キー入力旧状態（チャタリング防止）
k_space_old = 0
k_esc_old   = 0
k_q_old = 0 : k_w_old = 0 : k_a_old = 0 : k_s_old = 0
k_z_old = 0 : k_x_old = 0 : k_e_old = 0 : k_r_old = 0
k_d_old = 0 : k_f_old = 0 : k_c_old = 0 : k_v_old = 0
k_m_old = 0 : k_p_old = 0
k_i_old = 0 : k_o_old = 0

; マウス座標（初期は画面中央）
mx = double(SCRW/2)
my = double(SCRH/2)

;----------------------------------------
; メインループ
;----------------------------------------
*main
	; マウス座標更新（システム変数）
	mx = double(mousex)
	my = double(mousey)

	; プレイヤーのモジュールに座標を反映
	setX@BoidPlayer player, mx
	setY@BoidPlayer player, my

	; マウスがウィンドウ内ならプレイヤー影響を有効、外なら無効
	if mx >= 0 & mx < SCRW & my >= 0 & my < SCRH {
		setFlagEnabled@BoidPlayer player, 1
	} else {
		setFlagEnabled@BoidPlayer player, 0
	}

	gosub *updateKeys

	redraw 0
	gmode 0
	color 0,0,0 : boxf

	if running = 1 {
		gosub *updateBoids
	}

	gosub *drawParams
	gosub *drawBoids
	gosub *drawPlayer

	redraw 1
	await 16
	goto *main

;----------------------------------------
; キー入力サブルーチン（押した瞬間だけ反応）
;----------------------------------------
*updateKeys
	; Space: pause/resume
	getkey k_space, ' '
	if k_space = 1 & k_space_old = 0 {
		running = 1 - running
	}
	k_space_old = k_space

	; ESC: exit
	getkey k_esc, 27
	if k_esc = 1 & k_esc_old = 0 {
		end
	}
	k_esc_old = k_esc

	; Cohesion K (Q/W)
	getkey k_q, 'Q'
	if k_q = 1 & k_q_old = 0 {
		v = getCohesionK@BoidParam(param) + 0.01
		setCohesionK@BoidParam param, v
	}
	k_q_old = k_q

	getkey k_w, 'W'
	if k_w = 1 & k_w_old = 0 {
		v = getCohesionK@BoidParam(param) - 0.01
		if v < 0.0 { v = 0.0 }
		setCohesionK@BoidParam param, v
	}
	k_w_old = k_w

	; Alignment K (A/S)
	getkey k_a, 'A'
	if k_a = 1 & k_a_old = 0 {
		v = getAlignmentK@BoidParam(param) + 0.01
		setAlignmentK@BoidParam param, v
	}
	k_a_old = k_a

	getkey k_s, 'S'
	if k_s = 1 & k_s_old = 0 {
		v = getAlignmentK@BoidParam(param) - 0.01
		if v < 0.0 { v = 0.0 }
		setAlignmentK@BoidParam param, v
	}
	k_s_old = k_s

	; Player influence radius adjust (Z/X) ? BoidPlayer.addRadius
	getkey k_z, 'Z'
	if k_z = 1 & k_z_old = 0 {
		addRadius@BoidPlayer player, 10.0
	}
	k_z_old = k_z

	getkey k_x, 'X'
	if k_x = 1 & k_x_old = 0 {
		addRadius@BoidPlayer player, -10.0
	}
	k_x_old = k_x

	; Vision (E/R)
	getkey k_e, 'E'
	if k_e = 1 & k_e_old = 0 {
		v = getVision@BoidParam(param) + 5.0
		setVision@BoidParam param, v
	}
	k_e_old = k_e

	getkey k_r, 'R'
	if k_r = 1 & k_r_old = 0 {
		v = getVision@BoidParam(param) - 5.0
		if v < 5.0 { v = 5.0 }
		setVision@BoidParam param, v
	}
	k_r_old = k_r

	; MaxSpeed (D/F) -- F 下限 0.1
	getkey k_d, 'D'
	if k_d = 1 & k_d_old = 0 {
		v = getMaxSpeed@BoidParam(param) + 0.1
		setMaxSpeed@BoidParam param, v
	}
	k_d_old = k_d

	getkey k_f, 'F'
	if k_f = 1 & k_f_old = 0 {
		v = getMaxSpeed@BoidParam(param) - 0.1
		if v < 0.1 { v = 0.1 }
		setMaxSpeed@BoidParam param, v
	}
	k_f_old = k_f

	; Separation K (I/O)
	getkey k_i, 'I'
	if k_i = 1 & k_i_old = 0 {
		v = getSeparationK@BoidParam(param) + 0.01
		setSeparationK@BoidParam param, v
	}
	k_i_old = k_i

	getkey k_o, 'O'
	if k_o = 1 & k_o_old = 0 {
		v = getSeparationK@BoidParam(param) - 0.01
		if v < 0.0 { v = 0.0 }
		setSeparationK@BoidParam param, v
	}
	k_o_old = k_o

	; Wall mode toggle (M)
	getkey k_m, 'M'
	if k_m = 1 & k_m_old = 0 {
		setWallMode@BoidParam param, 1 - getWallMode@BoidParam(param)
	}
	k_m_old = k_m

	; Player mode toggle (P) ? Follow <-> Avoid
	getkey k_p, 'P'
	if k_p = 1 & k_p_old = 0 {
		if getMode@BoidPlayer(player) = 1 {
			setMode@BoidPlayer player, 2
		} else {
			setMode@BoidPlayer player, 1
		}
	}
	k_p_old = k_p

	return

;----------------------------------------
; Boid 更新（群行動 + プレイヤー追従/回避）
;----------------------------------------
*updateBoids
	vision = getVision@BoidParam(param)
	sepR   = getSeparateR@BoidParam(param)
	cohK   = getCohesionK@BoidParam(param)
	aliK   = getAlignmentK@BoidParam(param)
	sepK   = getSeparationK@BoidParam(param)
	maxSpd = getMaxSpeed@BoidParam(param)
	wmode  = getWallMode@BoidParam(param)

	mouseK = 0.12

	; プレイヤー情報をローカルに取り出す
	pradius = getRadius@BoidPlayer(player)
	pmode = getMode@BoidPlayer(player)
	px = getX@BoidPlayer(player)
	py = getY@BoidPlayer(player)
	pflag = getFlagEnabled@BoidPlayer(player)

	repeat NUM_BOIDS
		i = cnt
		x = getX@BoidObject(boids(i))
		y = getY@BoidObject(boids(i))
		vx = getVX@BoidObject(boids(i))
		vy = getVY@BoidObject(boids(i))

		sumx = 0.0 : sumy = 0.0
		sumvx = 0.0 : sumvy = 0.0
		sepx = 0.0 : sepy = 0.0
		nCoh = 0 : nSep = 0

		repeat NUM_BOIDS
			j = cnt
			if j = i { continue }
			x2 = getX@BoidObject(boids(j))
			y2 = getY@BoidObject(boids(j))
			vx2 = getVX@BoidObject(boids(j))
			vy2 = getVY@BoidObject(boids(j))

			dx = x2 - x
			dy = y2 - y
			d2 = dx*dx + dy*dy
			if d2 = 0.0 { continue }

			if d2 < vision * vision {
				sumx += x2 : sumy += y2
				sumvx += vx2 : sumvy += vy2
				nCoh++
			}

			if d2 < sepR * sepR {
				d = sqrt(d2)
				if d > 0.0 {
					sepx += (x - x2) / d
					sepy += (y - y2) / d
					nSep++
				}
			}
		loop

		; Cohesion + Alignment
		if nCoh > 0 {
			avgx = sumx / nCoh : avgy = sumy / nCoh
			vx += (avgx - x) * cohK
			vy += (avgy - y) * cohK

			avgvx = sumvx / nCoh : avgvy = sumvy / nCoh
			vx += (avgvx - vx) * aliK
			vy += (avgvy - vy) * aliK
		}

		; Separation
		if nSep > 0 {
			vx += sepx * sepK
			vy += sepy * sepK
		}

		; プレイヤー誘導/回避（有効フラグかつ半径内のみ）
		if pflag != 0 {
			ddx = px - x
			ddy = py - y
			dd = sqrt(ddx*ddx + ddy*ddy)
			if dd > 0.0 & dd < pradius {
				if pmode = 1 {
					vx += (ddx / dd) * mouseK
					vy += (ddy / dd) * mouseK
				} else {
					vx -= (ddx / dd) * mouseK
					vy -= (ddy / dd) * mouseK
				}
			}
		}

		; 速度制限
		sp = sqrt(vx*vx + vy*vy)
		if sp > maxSpd {
			vx = vx / sp * maxSpd
			vy = vy / sp * maxSpd
		}

		; 位置更新
		x += vx : y += vy

		; 壁処理（Wrap / Reflect）
		if wmode = 0 {
			if x < 0.0 { x += SCRW }
			if x >= SCRW { x -= SCRW }
			if y < 0.0 { y += SCRH }
			if y >= SCRH { y -= SCRH }
		} else {
			if x < 0.0 { x = 0.0 : vx = -vx }
			if x > SCRW { x = SCRW : vx = -vx }
			if y < 0.0 { y = 0.0 : vy = -vy }
			if y > SCRH { y = SCRH : vy = -vy }
		}

		setX@BoidObject boids(i), x
		setY@BoidObject boids(i), y
		setVX@BoidObject boids(i), vx
		setVY@BoidObject boids(i), vy
	loop
	return

;----------------------------------------
; Boid 描画（三角形）
;----------------------------------------
*drawBoids
	repeat NUM_BOIDS
		x = getX@BoidObject(boids(cnt))
		y = getY@BoidObject(boids(cnt))
		vx = getVX@BoidObject(boids(cnt))
		vy = getVY@BoidObject(boids(cnt))

		ang = atan(vy, vx)
		size = 6.0
		x1 = x + cos(ang) * size : y1 = y + sin(ang) * size
		x2 = x + cos(ang + pi*0.75) * (size * 0.5) : y2 = y + sin(ang + pi*0.75) * (size * 0.5)
		x3 = x + cos(ang - pi*0.75) * (size * 0.5) : y3 = y + sin(ang - pi*0.75) * (size * 0.5)

		color 0,255,255
		line x1, y1, x2, y2
		line x2, y2, x3, y3
		line x3, y3, x1, y1
	loop
	return

;----------------------------------------
; プレイヤー描画（中心は塗り、影響範囲は外縁のみ）
;----------------------------------------
*drawPlayer
	px = getX@BoidPlayer(player)
	py = getY@BoidPlayer(player)
	pr = getRadius@BoidPlayer(player)
	pm = getMode@BoidPlayer(player)

	if pm = 1 {
		color 0,255,0    ; Follow = 緑
	} else {
		color 255,0,0    ; Avoid = 赤
	}
	circle px-5, py-5, px+5, py+5    ; 塗りの中心表示

	; 影響範囲の外縁のみ描画（第5引数 0）
	color 255,255,255
	circle px-pr, py-pr, px+pr, py+pr, 0

	return

;----------------------------------------
; パラメータ表示
;----------------------------------------
*drawParams
	color 255,255,255
	pos 10,10
	mes "VISION=" + double(getVision@BoidParam(param))
	pos 10,30
	mes "SEPARATE_R=" + double(getSeparateR@BoidParam(param))
	pos 10,50
	mes "COHESION_K=" + double(getCohesionK@BoidParam(param))
	pos 10,70
	mes "ALIGNMENT_K=" + double(getAlignmentK@BoidParam(param))
	pos 10,90
	mes "SEPARATION_K=" + double(getSeparationK@BoidParam(param))
	pos 10,110
	mes "MAXSPEED=" + double(getMaxSpeed@BoidParam(param))
	pos 10,130
	if getWallMode@BoidParam(param) = 0 {
		mes "WALLMODE=Wrap (M to toggle)"
	} else {
		mes "WALLMODE=Reflect (M to toggle)"
	}
	pos 10,150
	if running = 1 {
		mes "Running: Yes (Space to Pause)"
	} else {
		mes "Running: No  (Space to Resume)"
	}
	pos 10,170
	mes "PLAYER_RADIUS=" + getRadius@BoidPlayer(player)
	pos 10,190
	if getMode@BoidPlayer(player) = 1 {
		mes "PLAYER_MODE=Follow (P to toggle)"
	} else {
		mes "PLAYER_MODE=Avoid (P to toggle)"
	}
	return
