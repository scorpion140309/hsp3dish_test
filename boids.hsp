;
#include "hsp3dish.as"

;
#include "BoidParam.as"
#include "BoidObject.as"

#const NUM_BOIDS 24
#const SCRW 640.0
#const SCRH 800.0
pi = 3.14159265358979

;----------------------------------------
; 初期化
;----------------------------------------
screen 0, int(SCRW), int(SCRH)
cls
randomize

newmod param, BoidParam

; Boid 配列生成
repeat NUM_BOIDS
	newmod boids, BoidObject
loop

; Boid 初期化（ランダム）
repeat NUM_BOIDS
	setX@BoidObject boids(cnt), double(rnd(SCRW))
	setY@BoidObject boids(cnt), double(rnd(SCRH))
	a = double(rnd(628))/100.0
	setVX@BoidObject boids(cnt), cos(a)
	setVY@BoidObject boids(cnt), sin(a)
loop

; 実行制御・キー押下旧状態（チャタリング防止）
running = 1
k_space_old = 0
k_esc_old   = 0
k_q_old = 0 : k_w_old = 0 : k_a_old = 0 : k_s_old = 0
k_z_old = 0 : k_x_old = 0 : k_e_old = 0 : k_r_old = 0
k_d_old = 0 : k_f_old = 0 : k_c_old = 0 : k_v_old = 0
k_m_old = 0

; マウス座標（フレーム毎更新）
mx = 0.0 : my = 0.0

;----------------------------------------
; メインループ
;----------------------------------------
*main
	; マウス座標を取得（システム変数）
	mx = double(mousex)
	my = double(mousey)

	gosub *updateKeys

	redraw 0
	gmode 0
	color 0,0,0 : boxf

	if running = 1 {
		gosub *updateBoids
	}

	gosub *drawParams
	gosub *drawBoids

	redraw 1
	await 16
	goto *main

;----------------------------------------
; キー入力サブルーチン（押された瞬間だけ反応）
;----------------------------------------
*updateKeys
	; Space: pause/resume (getkey でもよいが VK スキャン的に stick を併用しない設計で)
	getkey k_space, 32
	if k_space = 1 & k_space_old = 0 {
		running = 1 - running
	}
	k_space_old = k_space

	; ESC: exit
	getkey k_esc, 27
	if k_esc = 1 & k_esc_old = 0 {
		end
	}
	k_esc_old = k_esc

	; Cohesion K (Q/W)
	getkey k_q, 'Q'
	if k_q = 1 & k_q_old = 0 {
		v = getCohesionK@BoidParam(param) + 0.01
		setCohesionK@BoidParam param, v
	}
	k_q_old = k_q

	getkey k_w, 'W'
	if k_w = 1 & k_w_old = 0 {
		v = getCohesionK@BoidParam(param) - 0.01
		if v < 0.0 { v = 0.0 }
		setCohesionK@BoidParam param, v
	}
	k_w_old = k_w

	; Alignment K (A/S)
	getkey k_a, 'A'
	if k_a = 1 & k_a_old = 0 {
		v = getAlignmentK@BoidParam(param) + 0.01
		setAlignmentK@BoidParam param, v
	}
	k_a_old = k_a

	getkey k_s, 'S'
	if k_s = 1 & k_s_old = 0 {
		v = getAlignmentK@BoidParam(param) - 0.01
		if v < 0.0 { v = 0.0 }
		setAlignmentK@BoidParam param, v
	}
	k_s_old = k_s

	; Separation K (Z/X)
	getkey k_z, 'Z'
	if k_z = 1 & k_z_old = 0 {
		v = getSeparationK@BoidParam(param) + 0.01
		setSeparationK@BoidParam param, v
	}
	k_z_old = k_z

	getkey k_x, 'X'
	if k_x = 1 & k_x_old = 0 {
		v = getSeparationK@BoidParam(param) - 0.01
		if v < 0.0 { v = 0.0 }
		setSeparationK@BoidParam param, v
	}
	k_x_old = k_x

	; Vision (E/R)
	getkey k_e, 'E'
	if k_e = 1 & k_e_old = 0 {
		v = getVision@BoidParam(param) + 5.0
		setVision@BoidParam param, v
	}
	k_e_old = k_e

	getkey k_r, 'R'
	if k_r = 1 & k_r_old = 0 {
		v = getVision@BoidParam(param) - 5.0
		if v < 5.0 { v = 5.0 }
		setVision@BoidParam param, v
	}
	k_r_old = k_r

	; MaxSpeed (D/F) -- F 下限は 0.1 にする
	getkey k_d, 'D'
	if k_d = 1 & k_d_old = 0 {
		v = getMaxSpeed@BoidParam(param) + 0.1
		setMaxSpeed@BoidParam param, v
	}
	k_d_old = k_d

	getkey k_f, 'F'
	if k_f = 1 & k_f_old = 0 {
		v = getMaxSpeed@BoidParam(param) - 0.1
		if v < 0.1 { v = 0.1 }
		setMaxSpeed@BoidParam param, v
	}
	k_f_old = k_f

	; Separate radius (C/V)
	getkey k_c, 'C'
	if k_c = 1 & k_c_old = 0 {
		v = getSeparateR@BoidParam(param) + 1.0
		setSeparateR@BoidParam param, v
	}
	k_c_old = k_c

	getkey k_v, 'V'
	if k_v = 1 & k_v_old = 0 {
		v = getSeparateR@BoidParam(param) - 1.0
		if v < 1.0 { v = 1.0 }
		setSeparateR@BoidParam param, v
	}
	k_v_old = k_v

	; Wall mode toggle (M)
	getkey k_m, 'M'
	if k_m = 1 & k_m_old = 0 {
		setWallMode@BoidParam param, 1 - getWallMode@BoidParam(param)
	}
	k_m_old = k_m

	return

;----------------------------------------
; Boid 更新サブルーチン（マウス誘導：左ボタンを getkey で判定）
;----------------------------------------
*updateBoids
	vision = getVision@BoidParam(param)
	sepR   = getSeparateR@BoidParam(param)
	cohK   = getCohesionK@BoidParam(param)
	aliK   = getAlignmentK@BoidParam(param)
	sepK   = getSeparationK@BoidParam(param)
	maxSpd = getMaxSpeed@BoidParam(param)
	wmode  = getWallMode@BoidParam(param)

	; マウス誘導の強さ（必要なら変数化してキーで調整可）
	mouseK = 0.12

	repeat NUM_BOIDS
		i = cnt
		x = getX@BoidObject(boids(i))
		y = getY@BoidObject(boids(i))
		vx = getVX@BoidObject(boids(i))
		vy = getVY@BoidObject(boids(i))

		sumx = 0.0 : sumy = 0.0
		sumvx = 0.0 : sumvy = 0.0
		sepx = 0.0 : sepy = 0.0
		nCoh = 0 : nSep = 0

		repeat NUM_BOIDS
			j = cnt
			if j = i : continue
			x2 = getX@BoidObject(boids(j))
			y2 = getY@BoidObject(boids(j))
			vx2 = getVX@BoidObject(boids(j))
			vy2 = getVY@BoidObject(boids(j))

			dx = x2 - x
			dy = y2 - y
			d2 = dx*dx + dy*dy
			if d2 = 0.0 : continue

			if d2 < vision * vision {
				sumx += x2 : sumy += y2
				sumvx += vx2 : sumvy += vy2
				nCoh++
			}

			if d2 < sepR * sepR {
				d = sqrt(d2)
				if d > 0.0 {
					sepx += (x - x2) / d
					sepy += (y - y2) / d
					nSep++
				}
			}
		loop

		; Cohesion + Alignment
		if nCoh > 0 {
			avgx = sumx / nCoh : avgy = sumy / nCoh
			vx += (avgx - x) * cohK
			vy += (avgy - y) * cohK

			avgvx = sumvx / nCoh : avgvy = sumvy / nCoh
			vx += (avgvx - vx) * aliK
			vy += (avgvy - vy) * aliK
		}

		; Separation
		if nSep > 0 {
			vx += sepx * sepK
			vy += sepy * sepK
		}

		; マウス誘導 ? 左ボタンを getkey で検出（1 = マウス左ボタン）
		getkey m_left, 1
		if m_left = 1 {
			dx = mx - x
			dy = my - y
			dd = sqrt(dx*dx + dy*dy)
			if dd > 0.0 {
				vx += (dx / dd) * mouseK
				vy += (dy / dd) * mouseK
			}
		}

		; 速度制限
		sp = sqrt(vx*vx + vy*vy)
		if sp > maxSpd {
			vx = vx / sp * maxSpd
			vy = vy / sp * maxSpd
		}

		; 位置更新
		x += vx : y += vy

		; 壁処理
		if wmode = 0 {
			if x < 0.0	 { x += SCRW }
			if x >= SCRW  { x -= SCRW }
			if y < 0.0	 { y += SCRH }
			if y >= SCRH  { y -= SCRH }
		} else {
			if x < 0.0	 { x = 0.0 : vx = -vx }
			if x > SCRW	 { x = SCRW : vx = -vx }
			if y < 0.0	 { y = 0.0 : vy = -vy }
			if y > SCRH	 { y = SCRH : vy = -vy }
		}

		setX@BoidObject boids(i), x
		setY@BoidObject boids(i), y
		setVX@BoidObject boids(i), vx
		setVY@BoidObject boids(i), vy
	loop
	return

;----------------------------------------
; Boid 描画
;----------------------------------------
*drawBoids
	repeat NUM_BOIDS
		x = getX@BoidObject(boids(cnt))
		y = getY@BoidObject(boids(cnt))
		vx = getVX@BoidObject(boids(cnt))
		vy = getVY@BoidObject(boids(cnt))

		ang = atan(vy, vx)
		size = 6.0
		x1 = x + cos(ang) * size : y1 = y + sin(ang) * size
		x2 = x + cos(ang + pi*0.75) * (size*0.5) : y2 = y + sin(ang + pi*0.75) * (size*0.5)
		x3 = x + cos(ang - pi*0.75) * (size*0.5) : y3 = y + sin(ang - pi*0.75) * (size*0.5)

		color 0,255,255
		line x1, y1, x2, y2
		line x2, y2, x3, y3
		line x3, y3, x1, y1
	loop
	return

;----------------------------------------
; パラメータ表示サブルーチン
;----------------------------------------
*drawParams
	color 255,255,255
	pos 10,10
	mes "VISION=" + double(getVision@BoidParam(param))
	pos 10,30
	mes "SEPARATE_R=" + double(getSeparateR@BoidParam(param))
	pos 10,50
	mes "COHESION_K=" + double(getCohesionK@BoidParam(param))
	pos 10,70
	mes "ALIGNMENT_K=" + double(getAlignmentK@BoidParam(param))
	pos 10,90
	mes "SEPARATION_K=" + double(getSeparationK@BoidParam(param))
	pos 10,110
	mes "MAXSPEED=" + double(getMaxSpeed@BoidParam(param))
	pos 10,130
	if getWallMode@BoidParam(param) = 0 {
		mes "WALLMODE=Wrap (M to toggle)"
	} else {
		mes "WALLMODE=Reflect (M to toggle)"
	}
	pos 10,150
	if running = 1 {
		mes "Running: Yes (Space to Pause)"
	} else {
		mes "Running: No  (Space to Resume)"
	}
	return
